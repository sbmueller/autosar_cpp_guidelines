> **Rule A8-5-3 (required, implementation, automated)**
>
> A variable of type auto shall not be initialized using {} or
> ={} braced-initialization.

## Rationale

If an initializer of a variable of type auto is enclosed in braces, then the result of type
deduction may lead to developer confusion, as the variable initialized using {} or ={}
will always be of std::initializer_list type.
Note that some compilers, e.g. GCC or Clang, can implement this differently initializing a variable of type auto using {} will deduce an integer type, and initializing
using ={} will deduce a std::initializer_list type. This is desirable type deduction which
will be introduced into the C++ Language Standard with C++17.

## Example

```cpp
// $Id: A8-5-3.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include <cstdint>
#include <initializer_list>

void Fn() noexcept
{
    auto x1(10); // Compliant - the auto-declared variable is of type int, but
                 // not compliant with A8-5-2.
    auto x2{10}; // Non-compliant - according to C++14 standard the
                 // auto-declared variable is of type std::initializer_list.
                 // However, it can behave differently on different compilers.
    auto x3 = 10; // Compliant - the auto-declared variable is of type int, but
                  // non-compliant with A8-5-2.
    auto x4 = {10}; // Non-compliant - the auto-declared variable is of type
                    // std::initializer_list, non-compliant with A8-5-2.
    std::int8_t x5{10}; // Compliant
}
```

## See also

Effective Modern C++ [13]: Item 2. Understand auto type deduction.

Effective Modern C++ [13]: Item 7. Distinguish between () and {} when creating
objects.
